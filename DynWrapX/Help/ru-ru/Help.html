<html>
<head>
  <meta charset="windows-1251">
  <title>Справка DynamicWrapperX</title>
  <style type="text/css">
    body {background:#dfdfdf; margin-top:0}
    div.text {margin:0 5%; padding:1px 1%; background:#e2e2e2; font:9pt/11pt Verdana} 
    pre {background:#eaeaea; color:navy; padding:3px; margin:4px 0 8px 0; font:10pt/12pt; overflow:auto}
    pre span {color:black}
    p {margin:5px 0; text-align:justify}
    span.cmd {color:navy}
    #top {margin-top:8px; font:14pt/17pt; font-weight:700; text-align:center}
    h3 {font:12pt/14pt; font-weight:700}
    a {color:#00a}
    a:Visited {color:#00a}
    a:Hover {color:#0a0}
    ul {margin-top:0}
    ol {margin-top:0; margin-bottom:0}
  </style>
</head>

<body>
<div class="text">
    <h2 id="top">DynamicWrapperX 2.0</h2>
    <p>
    Автор: <a href="mailto:waitabit@bk.ru">Юрий Попов</a><br>
    Лицензия: freeware
    <h3 id="contents">Содержание</h3>
    <ul>
      <li><a href="#intro">Введение</a>
      <li><a href="#regsvr">Регистрация в системе</a>
      <li><a href="#methods">Встроенные методы</a>
      <li><a href="#inparams">Входные параметры и возвращаемые значения</a>
      <li><a href="#outparams">Выходные параметры</a>
      <li><a href="#strings">О строках</a>
    </ul>
  
    <h3 id="intro">Введение</h3>
<p><u>DynamicWrapperX</u> — это ActiveX компонент (СОМ-сервер), написанный мной по мотивам <a href="http://script-coding.com/dynwrap.html">DynamicWrapper</a> как попытка более полной реализации идеи. Он предоставляет возможность в скриптах на JScript и VBScript регистрировать в качестве методов объекта и затем вызывать функции, экспортируемые dll-библиотеками, в частности функции Windows API. С версии 2 также возможна регистрация функции по её адресу в памяти и регистрация машинного кода функции, представленного в виде хекс-строки. Этот компонент не является модификацией оригинального кода DynamicWrapper, он написан с нуля на языке ассемблера GoAsm. Версия 2.0 тестировалась под Windows XP SP3, Windows 7 SP1 и Windows 8.1.
<p>
Нововведения в версии 1 по отношению к DynamicWrapper:
<ul>
  <li>Добавлена возможность регистрации компонента в системе для текущего пользователя. Это может пригодиться, если у пользователя нет прав администратора.
  <li>Расширен набор типов входных параметров и возвращаемых значений.
  <li>Добавлены выходные параметры.
  <li>Унифицирована работа со строками в JScript и VBScript.
  <li>Реализован обратный вызов (callback), т.е. возможность для функций API в свою очередь вызывать функции скрипта. Последнее нужно для использования таких API-функций, как EnumWindows (см. примеры ниже).
  <li>Под Windows 98 отпала необходимость создавать отдельный объект для каждой используемой функции.
  <li>Добавлено несколько полезных, на мой взгляд, встроенных методов.
</ul>
<p>
<p>
Изменения в версии 2 по отношению к версии 1:
<ul>
  <li>Компонент не тестировался под Windows 98 и официально её не поддерживает.
  <li>Доступны два варианта: x86 и x64.
  <li>Изменён CLSID компонента.
  <li>При установке и удалении проверяется наличие 1-й версии; дальнейшее зависит от результатов проверки (см. раздел Регистрация в системе).
  <li>Расширен набор типов параметров и возвращаемых значений: добавлены типы <b>m</b> (Int64), <b>q</b> (UInt64), <b>v</b> (VARIANT).
  <li>Количество callback-функций теперь неограничено.
  <li>Расширены возможности метода Register (регистрация функции по ординалу, регистрация под другим именем, добавлен флаговый параметр "f=").
  <li>Добавлены встроенные методы RegisterAddr, RegisterCode, StrPut, ObjPtr, ObjGet, ArrPtr, VarPtr, MemAlloc, MemFree, Bitness, Version.
  <li>В методах StrPtr, StrGet, StrPut вместо типа строки можно прямо указать её кодировку.
</ul>
<p>
---------------------------------------------------------------------------<br>
<p>
P.S. Хотя я и постарался протестировать компонент в различных ситуациях, идеальную его работу гарантировать не могу. Буду благодарен за сообщения <a href="http://forum.script-coding.com">на форуме</a> о глюках и багах, буде такие обнаружатся. 
<p>
<a href="#contents">Наверх</a>
 
   <h3 id="regsvr">Регистрация в системе</h3>
<p>
<u>Зарегистрировать</u> компонент можно двумя способами:<br>
<span class="cmd"><![CDATA[regsvr32.exe <путь-к-компоненту>\dynwrapx.dll]]></span> — для всех пользователей.<br>
<span class="cmd"><![CDATA[regsvr32.exe /i <путь-к-компоненту>\dynwrapx.dll]]></span> — для текущего пользователя.<br>
<p>
Если dynwrapx.dll лежит в папке System32, System, Windows, в текущей, или в одной из тех, что перечислены в переменной окружения Path, путь можно не указывать. При регистрации для текущего пользователя объект будет доступен только этому пользователю. Кроме того, в Windows Vista, Windows 7 и Windows 8 он будет недоступен для процессов, выполняющихся с правами администратора.
<p>
В 64-битной системе нужно зарегистрировать оба варианта, x86 и x64, чтобы компонент могли использовать как 64-, так и 32-битные приложения.
<p>
Если в системе уже зарегистрирована 1-я версия, 2-я регистрируется параллельно с ней. В этом случае она будет доступна в скриптах только по имени DynamicWrapperX.2. Чтобы заменить старую версию новой, нужно сначала разрегистрировать старую. В этом случае новая версия будет доступна также под именем DynamicWrapperX.
<p>
<u>Разрегистрировать</u> компонент можно так:<br>
<span class="cmd"><![CDATA[regsvr32.exe /u <путь-к-компоненту>\dynwrapx.dll]]></span> — для всех пользователей.<br>
<span class="cmd"><![CDATA[regsvr32.exe /u /i <путь-к-компоненту>\dynwrapx.dll]]></span> — для текущего пользователя.<br>
<p>
Если 2-я версия была установлена параллельно с 1-й, её разрегистрация никак не затронет регистрацию 1-й (и наоборот).
<p>
<a href="#contents">Наверх</a>
  
  <h3 id="methods">Встроенные методы объекта</h3>
  (щёлкните по номеру, чтобы перейти к подробному описанию)
<p>
<a href="#register">[1]</a> &nbsp<span class="cmd">Register( DllName[:Ordinal/:FuncName], FuncName [, i=ParamTypes] [, r=RetValType] [, f=Flags] )</span> — регистрация функции из DLL в качестве метода объекта.<br>
<a href="#regaddr">[2]</a> &nbsp<span class="cmd">RegisterAddr( Addr, FuncName, [, i=ParamTypes] [, r=RetValType] [, f=Flags] )</span> — регистрация функции по её адресу в памяти.<br>
<a href="#regcode">[3]</a> &nbsp<span class="cmd">RegisterCode( HexStr [, FuncName] [, i=ParamTypes] [, r=RetValType] [, f=Flags] )</span> — регистрация машинного кода функции, представленного в виде хекс-строки.<br>
<a href="#callback">[4]</a> &nbsp<span class="cmd">RegisterCallback( FuncRef [, i=ParamTypes] [, r=RetValType] )</span> — регистрация скриптовой функции как callback-функции.<br>
<a href="#addons">[5]</a> &nbsp<span class="cmd">NumGet( Address [, Offset] [, Type] )</span> — чтение числа из памяти по заданному адресу.<br>
<a href="#addons">[6]</a> &nbsp<span class="cmd">NumPut( Var, Address [, Offset] [, Type] )</span> — запись числа в память по заданному адресу.<br>
<a href="#addons">[7]</a> &nbsp<span class="cmd">StrPtr( Var [, Type/Codepage] )</span> — получение указателя на строку в виде числовой переменной.<br>
<a href="#addons">[8]</a> &nbsp<span class="cmd">StrGet( Address [, Type/Codepage] )</span> — считывание строки по заданному адресу (указателю).<br>
<a href="#addons">[9]</a> &nbsp<span class="cmd">StrPut( Str, Address [, Type/Codepage] )</span> — запись строки по указанному адресу.<br>
<a href="#addons">[10]</a> &nbsp<span class="cmd">Space( Count [, Char] )</span> — создание строки заданной длины.<br>
<a href="#addons">[11]</a> &nbsp<span class="cmd">ObjPtr( Object )</span> — получение указателя на объект.<br>
<a href="#addons">[12]</a> &nbsp<span class="cmd">ObjGet( ObjPtr )</span> — получение объекта по указателю на него.<br>
<a href="#addons">[13]</a> &nbsp<span class="cmd">ArrPtr( Array )</span> — получение указателя на структуру SAFEARRAY массива.<br>
<a href="#addons">[14]</a> &nbsp<span class="cmd">VarPtr( Variable )</span> — получение указателя на структуру VARIANT скриптовой переменной.<br>
<a href="#addons">[15]</a> &nbsp<span class="cmd">MemAlloc( Bytes [, ZeroMem] )</span> — выделение памяти.<br>
<a href="#addons">[16]</a> &nbsp<span class="cmd">MemFree( MemPtr )</span> — освобождение памяти.<br>
<a href="#addons">[17]</a> &nbsp<span class="cmd">Bitness()</span> — получение битности (32 или 64) используемого объекта DynamicWrapperX.<br>
<a href="#addons">[18]</a> &nbsp<span class="cmd">Version( [Field] )</span> — возвращает указанное поле/поля из полного номера версии DynamicWrapperX.
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="register">Метод Register</h3>
<p>
Этот метод регистрирует функцию, находящуюся в указанной dll-библиотеке, в качестве метода объекта. После этого она может вызываться так же, как и встроенные методы, по своему имени через точку. Первый параметр — имя библиотеки; второй — имя функции. Наличие остальных параметров зависит от функции, порядок их произвольный, т.к. они различаются по префиксу. Префикс <b>i=</b> обозначает параметры функции, <b>r=</b> — возвращаемое значение, <b>f=</b> — флаги, влияющие на то, как будет вызываться функция (см. описание ниже).
<p>
<b>JScript</b>
<pre>
DWX = new ActiveXObject("DynamicWrapperX");                  <span>// Создание объекта.</span>
DWX.Register("user32.dll", "MessageBoxW", "i=hwwu", "r=l");  <span>// Регистрация функции из dll.</span>
res = DWX.MessageBoxW(0, "Hello, world!", "Test", 4);        <span>// Вызов.</span>
</pre>
<p>
<b>VBScript</b>
<pre>
Set DWX = CreateObject("DynamicWrapperX")                    <span>' Создание объекта.</span>
DWX.Register "user32.dll", "MessageBoxW", "i=hwwu", "r=l"    <span>' Регистрация функции из dll.</span>
res = DWX.MessageBoxW(0, "Hello, world!", "Test", 4)         <span>' Вызов.</span>
</pre>
<p>
<u>Имя библиотеки</u>, указанное без пути к ней, означает поиск по имени — сначала в памяти процесса среди уже загруженных библиотек (в порядке их загрузки), затем на диске. В Windows XP порядок поиска на диске будет таким:
<ol>
  <li>Каталог приложения (в данном случае приложение — это либо wscript.exe, либо cscript.exe)
  <li>Текущий каталог
  <li>System32
  <li>System
  <li>Windows
  <li>Каталоги, перечисленные в переменной окружения Path
</ol>
<p>
Если библиотека находится в файле с расширением dll, расширение указывать не обязательно, т.е. выше можно было бы написать просто "user32". Если библиотека находится в файле без расширения, в конце имени нужно поставить точку, например: "mylib."
<p>
Если функция регистрируется по её ординалу, он указывается рядом с именем библиотеки через двоеточие. То же самое, если функция регистрируется с заменой имени. Последнее может пригодиться, если имя функции содержит символы, недопустимые для имён методов в используемом скриптовом языке.
<p>
Учтите, что ординал функции может быть разным в разных версиях библиотеки и в x86 и x64 вариантах одной и той же версии.
<p>
Ординал можно задавать десятичным или шестнадцатеричным числом (с префиксом 0x).
<p>
<b>JScript</b>
<pre>
DWX.Register("user32:110", "MethodName", "i=hwwu", "r=l");  <span>// Регистрация функции по ординалу.</span>
DWX.Register("user32:BadName", "GoodName", "i=hwwu", "r=l"; <span>// Регистрация с заменой имени.</span>
</pre>
<p>
<b>VBScript</b>
<pre>
DWX.Register "user32:110", "MethodName", "i=hwwu", "r=l"  <span> ' Регистрация функции по ординалу.</span>
DWX.Register "user32:BadName", "GoodName", "i=hwwu", "r=l" <span>' Регистрация с заменой имени.</span>
</pre>
<p>
<u>Имя функции</u> в Windows API может иметь варианты. Например, функция, описанная в документации как MessageBox, реально присутствует в user32.dll в двух воплощениях: MessageBoxW (для строк в Юникоде) и MessageBoxA (для строк в традиционной 8-битной кодировке ANSI). Следуя традиции, я сохранил логику поиска функций прежней: например, если указано имя MessageBox и такой функции в user32.dll не будет найдено, то поиск автоматически повторяется для варианта MessageBoxA. Имена юникодовских функций нужно указывать точно, с буквой W на конце.
<p>
<u>Список параметров</u> можно опускать, только если функция таковых не имеет, при этом не нужно оставлять на этом месте запятую.
<p>
<u>Возвращаемое значение</u>, если оно не требуется, можно опускать независимо от того, возвращает что-то функция или нет.
<p>
<b>JScript</b>
<pre>
DWX = new ActiveXObject("DynamicWrapperX");
DWX.Register("kernel32", "GetCommandLine", "r=s");      <span>// У этой функции нет параметров.</span>
CmdLine = DWX.GetCommandLine();                         <span>// Команда, запустившая данный процесс.</span>
WScript.Echo(CmdLine);
</pre>
<p>
<b>VBScript</b>
<pre>
Set DWX = CreateObject("DynamicWrapperX")
DWX.Register "kernel32", "Beep", "i=uu"      <span>' Функция Beep возвращает значение, но оно не нужно.</span>
DWX.Beep 800, 1000                           <span>' Звук через динамик системного блока.</span>
</pre>
<p>
<u>Флаговый параметр</u> на данный момент имеет только одно возможное значение "t", обозначающее, что функция использует соглашение вызова thiscall. Оно принимается во внимание только 32-битным DynamicWrapperX, а 64-битным игнорируется.
<p>
<b>JScript</b>
<pre>
DWX.Register("SomeLib", "SomeFunc", "i=hwwu", "r=l", "f=t");  <span>// Использовать thiscall при вызове функции.</span>
</pre>
<p>
<b>VBScript</b>
<pre>
DWX.Register "SomeLib", "SomeFunc", "i=hwwu", "r=l", "f=t"  <span>' Использовать thiscall при вызове функции.</span>
</pre>
<p>
<a href="#contents">Наверх</a>

    <h3 id="regaddr">Метод RegisterAddr</h3>
<p>
Этот метод регистрирует функцию по её адресу в памяти. Остальные параметры те же, что и у Register.
<p>
<b>JScript</b>
<pre>
DWX.RegisterAddr(Address, "FuncName", "i=hwwu", "r=l");
</pre>
<p>
<b>VBScript</b>
<pre>
DWX.RegisterAddr Address, "FuncName", "i=hwwu", "r=l"
</pre>
<p>
<a href="#contents">Наверх</a>

    <h3 id="regcode">Метод RegisterCode</h3>
<p>
Метод принимает в качестве первого аргумента машинный код функции, представленный в виде хекс-строки. Под код выделяется память, и он записывается туда уже в бинарном виде. После чего его можно вызывать по присвоенному ему во втором аргументе имени. Возвращаемое значение содержит адрес кода в памяти. Машинный код для 32 и 64 бит различен, отсюда необходимость проверки битности процесса (через проверку битности объекта DynamicWrapperX), чтобы определить, какой код использовать. В качестве возможного применения для такого кода можно привести обработку больших объёмов данных. Машинный код может работать в десятки или даже сотни раз быстрее скриптового.
<p>
Если вы хотите использовать код по его адресу, без создания метода, можно опустить все аргументы кроме первого. Но имейте в виду, что выделенная под код память всё же связана с объектом и будет освобождена в случае его уничтожения.
<p>
Хекс-строка может быть сплошной или содержать пробелы, табуляции и переводы строки.
<p>
<b>JScript</b>
<pre>
DWX = new ActiveXObject("DynamicWrapperX");

if (DWX.Bitness == 32) {
    Code = "8B442404F76C2408C3"  <span>// Функция возвращает произведение своих аргументов.</span>
}
else {
    Code = "4889C8 48F7EA C3"    <span>// mov rax,rcx; imul rdx; ret</span>
}
CodeAddr = DWX.RegisterCode(Code, "Multiply", "i=ll", "r=l");

WScript.Echo(DWX.Multiply(5, 4));
</pre>
<p>
<b>VBScript</b>
<pre>
Set DWX = CreateObject("DynamicWrapperX")

If DWX.Bitness = 32 Then
    Code = "8B442404F76C2408C3"  <span>' Функция возвращает произведение своих аргументов.</span>
Else
    Code = "4889C8 48F7EA C3"    <span>' mov rax,rcx; imul rdx; ret</span>
End If
CodeAddr = DWX.RegisterCode(Code, "Multiply", "i=ll", "r=l")

WScript.Echo(DWX.Multiply(5, 4))
</pre>
<p>
Комментарии можно поместить прямо в хекс-строку, обрамив их скобками.
<pre>
Code = "4889C8 (mov rax,rcx) 48F7EA (imul rdx) C3 (ret)"
</pre>
Если хекс-строка является многострочным текстом, комментарии можно обозначать точкой с запятой.
<p>
<b>JScript</b>
<pre>
Code = "4889C8  ; mov rax,rcx \n" +
       "48F7EA  ; imul rdx \n" +
       "C3      ; ret"
</pre>
<b>VBScript</b>
<pre>
Code = "4889C8  ; mov rax,rcx" & vbCrLf & _
       "48F7EA  ; imul rdx" & vbCrLf & _
       "C3      ; ret"
</pre>
<p>
Но учтите, что в этом случае каждая строка, кроме последней, должна иметь на конце перевод строки, т.к. он используется как признак конца комментария.
<p>
<a href="#contents">Наверх</a>

    <h3 id="inparams">Типы входных параметров и возвращаемых значений</h3>
<p>
<b>m</b> — знаковое целое 64 бита — INT64, LONGLONG, ...<br>
<b>q</b> — беззнаковое целое 64 бита — UINT64, ULONGLONG, ...<br>
<b>l</b> — знаковое целое 32 бита — LONG, INT, LRESULT, BOOL, ...<br>
<b>u</b> — беззнаковое целое 32 бита — ULONG, UINT, DWORD, ...<br>
<b>h</b> — хэндл, дескриптор — HANDLE, HWND, HMODULE, HINSTANCE, HICON, ... — 32 бита (x86) или 64 бита (x64)<br>
<b>p</b> — указатель, для чисел то же, что <b>u</b> (x86) или <b>q</b> (x64), но также можно использовать для передачи объекта (IDispatch *) и строки.<br>
<b>n</b> — знаковое целое 16 бит — SHORT<br>
<b>t</b> — беззнаковое целое 16 бит — USHORT, WORD, WCHAR, OLECHAR, ...<br>
<b>c</b> — знаковое целое 8 бит — CHAR<br>
<b>b</b> — беззнаковое целое 8 бит — UCHAR, BYTE, ...<br>
<b>f</b> — дробное число одинарной точности (32 бита) — FLOAT<br>
<b>d</b> — дробное число двойной точности (64 бита) — DOUBLE<br>
<b>w</b> — строка в Юникоде — BSTR, LPWSTR, LPOLESTR, OLECHAR *, WCHAR *, ...<br>
<b>s</b> — строка в кодировке ANSI/Windows по умолчанию — LPSTR, LPCSTR, CHAR *, ...<br>
<b>z</b> — строка в кодировке OEM/DOS по умолчанию — LPSTR, LPCSTR, CHAR *, ...<br>
<b>v</b> — указатель на структуру VARIANT
<p>
Кроме хэндлов и указателей, есть и другие типы, меняющие свою битность с битностью процесса. Например, LPARAM, WPARAM, SIZE_T. Для них также лучше использовать тип <b>h</b> или <b>p</b>, чтобы код скрипта корректно работал при его выполнении как 32-, так и 64-битным скриптовым интерпретатором.
<p>
Типам <b>m</b> и <b>q</b> (а также <b>h</b> и <b>p</b> в x64) в скриптах соответствовали бы типы VT_I8 и VT_UI8. Движками JScript и VBScript эти типы не поддерживаются, что ограничивает возможности работы с 64-битными числами. До тех пор, пока значение возвращаемого функцией числа это позволяет, DynamicWrapperX преобразует его к типам VT_I4 (знаковое целое 32 бита) либо VT_R8 (дробное число двойной точности). Поскольку мантисса VT_R8 имеет только 53 бита, этот тип не может отобразить все числа в диапазоне 64-битного целого. В таком случае возвращается тип VT_I8 или VT_UI8. Всё, что можно с ними сделать в скрипте, — передать как аргумент в какой-то другой метод или вывести значение числа в WScript.Echo либо MsgBox. Никакие расчёты с ними невозможны.
<p>
Когда большое целое возвращается как VT_R8 и вы хотите посмотреть его значение в диалоговом окне, оно может отображаться неточно из-за ограничения на число знаков после запятой в строковом представлении дробного числа. Поэтому, например, число 9223372036854775808 может отобразиться как 9,22337203685478E+18 вместо 9,223372036854775808E+18. Однако само число в переменной не округляется и остаётся точным.
<p>
Если значение 64-битного целого не укладывается ни в один из доступных числовых типов, можно указать его в виде строки, десятичной или шестнадцатеричной (с префиксом 0x).
<pre>
DWX.Register("lib.dll", "func", "i=m")
DWX.func("0xFFFFFFFFFFFFFFFF")
DWX.func("-0x7FFFFFFFFFFFFFFF")
DWX.func("18446744073709551615")
DWX.func("-9223372036854775807")
</pre>
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="outparams">Выходные параметры</h3>
<p>
<b>M</b> — указатель на число (его адрес в памяти) — LONGLONG *, PLONGLONG и т.п.<br>
<b>Q</b> — то же — ULONGLONG *, PULONGLONG, ...<br>
<b>L</b> — то же — LONG *, LPLONG, ...<br>
<b>H</b> — то же — HANDLE *, PHANDLE, LPHANDLE, ...<br>
<b>U</b> — то же — ULONG *, LPDWORD, ...<br>
<b>P</b> — то же<br>
<b>N</b> — то же — SHORT *<br>
<b>T</b> — то же — USHORT *, LPWORD, WCHAR *, OLECHAR *, ...<br>
<b>C</b> — то же — CHAR *, ...<br>
<b>B</b> — то же — UCHAR *, LPBYTE, ...<br>
<b>F</b> — то же — FLOAT *, PFLOAT<br>
<b>D</b> — то же — DOUBLE *, PDOUBLE<br>
<b>W</b> — выходная строка в Юникоде<br>
<b>S</b> — выходная строка в ANSI<br>
<b>Z</b> — выходная строка в OEM
<p>
Использование выходных типов для чисел имеет смысл для скриптовых движков, которые передают переменные в метод по ссылке, как это делает VBScript. В этом случае DynamicWrapperX может передать функции указатель на значение переменной, которое функция может изменить. В движках, где аргументы передаются по значению, как в JScript, методу передаётся копия числа, поэтому изменить оригинал нет возможности. В этом случае решением будет выделение нужного количества памяти, например, методом MemAlloc, передача функции указателя на эту память (используя тип <b>p</b>) и затем, после вызова функции, считывание помещённого ею туда числа методом NumGet.
<p>
Некоторые движки копируют строки при передаче их в метод; в этом случае использование выходных типов для строк также теряет смысл. Решение аналогично: выделение памяти, передача указателя на неё типом <b>p</b> и затем считывание оттуда строки методом StrGet.
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="strings">О строках</h3>
<p>
В JScript и VBScript используются строки типа BSTR. Это строка в Юникоде, т.е. код каждого символа занимает 2 байта. За последним символом расположен ограничитель - 2 нулевых байта. Кроме того, перед первым символом находится 4-байтное число, содержащее длину строки в байтах (без учёта нулевых на конце). Указатель, содержащийся в скриптовых строковых переменных, является адресом первого символа такой строки (т.е. байты, содержащие длину строки, как бы остаются за кадром).
<p>
<u>Передать строку</u> можно тремя различными способами:
<p>
1) Входная строка: <b>w</b>, <b>s</b>, <b>z</b>. Для типов <b>s</b> и <b>z</b> строка копируется с конвертацией в соответствующую кодировку, и API-функция получает указатель на эту копию. После завершения работы функции память, запрошенная под копию строки, освобождается, т.е. эта копия перестаёт существовать. В случае <b>w</b> функции передаётся указатель на оригинал строки.
<p>
2) Выходная строка: <b>W</b>, <b>S</b>, <b>Z</b>. Передаётся указатель на оригинал строки, но <b>S</b> и <b>Z</b> предварительно конвертируются (на месте). После завершения функции строки <b>S</b> и <b>Z</b> конвертируются обратно в Юникод, у них измеряется длина, а у строки <b>W</b> только измеряется длина. Длина (в байтах) записывается перед строкой. Без этой последней операции потом в скрипте будут глюки, например, при конкатенации этой строки с другими.
<p>
3) Указатель: <b>p</b>. Это самый простой способ. Передаётся указатель на оригинал строки, без конвертации. После завершения функции нет ни конвертации, ни корректировки длины. Так что если функция туда что-то запишет, оно там будет в нетронутом виде. Здесь строка фактически является просто буфером в памяти для хранения любых данных.
<p>
Может показаться, что это то же самое, что <b>w</b>, но это не так. Разница в том, что параметр, объявленный как <b>p</b>, принимает не только строковые переменные, но и числовые.
<p>
<u>Возвращая строку</u> как <b>p</b>, получаем числовую переменную, содержащую указатель на строку, которую вернула функция. Возвращая строку как <b>w</b>, <b>s</b> или <b>z</b>, получаем строковую переменную, содержащую указатель на копию этой строки. Строки <b>s</b> и <b>z</b> копируются с конвертацией в Юникод.
<p>
Вызовы API, принимающие строковые аргументы, как правило, представлены в двух вариантах - например, MessageBoxA и MessageBoxW. Использование в скриптах юникодовских вариантов, с окончанием W, представляется более логичным, т.к. при этом нет дополнительных перекодировок строк туда и обратно.
<p>
<u>Выходная строка</u>, как и прочие выходные параметры, предназначена для того, чтобы функция API в неё что-нибудь записала, так что её длина должна быть соответствующей.
<p>
<u>Использование строк как буферов памяти</u> может работать или нет в зависимости от того, как внутри скриптового движка реализована работа со строками. Предпочтительнее выделять память методом MemAlloc, т.к. она будет под вашим полным контролем.
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="callback">Метод RegisterCallback</h3>
<p>
Этот метод нужен для получения указателя на скриптовую функцию, пригодного для передачи какой-либо функции API. Которая потом, используя этот указатель, могла бы данную скриптовую функцию вызывать. Примером API-функции, которая этого требует, может служить EnumWindows. Она перебирает существующие окна и хэндл каждого окна передаёт callback-функции в качестве параметра. После этого она ждёт, что вернёт callback-функция. Если 1, то перебор идёт дальше, если 0 — прекращается.
<p>
В JScript и VBScript функция является объектом и ссылка на неё для таких целей не годится. Поэтому ссылка на скриптовую функцию сначала передаётся методу RegisterCallback, а API-функция получает возвращённый им указатель на одну из вспомогательных процедур внутри dynwrapx.dll, вызовы которой будут транслироваться в вызовы скриптовой функции, а возвращаемые значения — в обратном направлении.
<p>
В JScript ссылка на функцию — это её имя, только без скобок, а в VBScript сначала нужно использовать GetRef. Кроме ссылки на функцию задаются также типы её параметров и возвращаемого значения — аналогично методу Register (но используются только маленькие буквы).
<p>
<b>JScript</b>
<pre>
DWX = new ActiveXObject("DynamicWrapperX");

DWX.Register("user32", "EnumWindows",    "i=ph");
DWX.Register("user32", "GetWindowTextW", "i=hpl");          <span>// Unicode</span>
//DWX.Register("user32", "GetWindowText", "i=hpl");         <span>// ANSI</span>

pCbkFunc = DWX.RegisterCallback(CbkEnumWin, "i=hh", "r=l"); <span>// Регистрация CbkEnumWin</span>
                                                            <span>// как функции обратного</span>
                                                            <span>// вызова и получение</span>
                                                            <span>// указателя.</span>
n=0, m=0, WinList="";

Buf = DWX.MemAlloc(256);             <span>// Буфер под заголовок окна (выходная строка).</span>

DWX.EnumWindows(pCbkFunc, 0);        <span>// Вызов EnumWindows с передачей ей указателя на</span>
                                     <span>// callback-функцию.</span>
DWX.MemFree(Buf);

WScript.Echo("Всего окон: " + m + "\nС заголовками: " + n + "\n\n" + WinList);


// ............... Собственно callback-функция ....................

function CbkEnumWin(hwnd, lparam)
{
    var Title;
    DWX.GetWindowTextW(hwnd, Buf, 128);     <span>// Unicode</span>
    Title = DWX.StrGet(Buf, "w");
    //DWX.GetWindowText(hwnd, Buf, 256);    <span>// ANSI</span>
    //Title = DWX.StrGet(Buf, "s");
    if(Title.length > 0) {  <span>// Если длина заголовка больше 0, заносим в список.</span>
        WinList += hwnd + "\t" + Title + "\n";
        ++n;
    }
    ++m;
    return 1;               <span>// Если вернуть 0, вызовы прекратятся.</span>
}
</pre>
<p>
<a href="#contents">Наверх</a>
<p>
&nbsp;
<p>
<b>VBScript</b>
<pre>
Set DWX = CreateObject("DynamicWrapperX")

DWX.Register "user32", "EnumWindows",    "i=ph"
DWX.Register "user32", "GetWindowTextW", "i=hpl"      <span>' Unicode</span>
'DWX.Register "user32", "GetWindowText", "i=hpl"      <span>' ANSI</span>

Set Ref = GetRef("CbkEnumWin")  ' Получение ссылки на функцию.

pCbkFunc = DWX.RegisterCallback(Ref, "i=hh", "r=l")   <span>' Регистрация CbkEnumWin</span>
                                                      <span>' как функции обратного вызова</span>
                                                      <span>' и получение указателя.</span>
n = 0 : m = 0 : WinList = ""
Buf = DWX.MemAlloc(256)           <span>' Буфер под заголовок окна (выходная строка).</span>

DWX.EnumWindows pCbkFunc, 0       <span>' Вызов EnumWindows с передачей ей указателя на</span>
                                  <span>' callback-функцию.</span>
DWX.MemFree Buf

WScript.Echo "Всего окон: " & m & vbCrLf & "С заголовками: " & n & _
              vbCrLf & vbCrLf & WinList


' ................ Собственно callback-функция .......................

Function CbkEnumWin(hwnd, lparam)
    DWX.GetWindowTextW hwnd, Buf, 128    <span>' Unicode</span>
    Title = DWX.StrGet(Buf, "w")
    'DWX.GetWindowText hwnd, Buf, 256    <span>' ANSI</span>
    'Title = DWX.StrGet(Buf, "s")
    If Len(Title) > 0 Then   <span>' Если длина заголовка больше 0, заносим в список.</span>
        WinList = WinList & hwnd & vbTab & Title & vbCrLf
        n = n+1
    End If
    m = m+1
    CbkEnumWin = 1           <span>' Если вернуть 0, вызовы прекратятся.</span>
End Function
</pre>
<p>
<a href="#contents">Наверх</a>
  
    <h3 id="addons">Дополнительные методы</h3>
<p>
<u>NB</u>: параметры в квадратных скобках необязательны, но нельзя опускать такой параметр, если следующий за ним вы указываете.
<p>
<span class="cmd">NumGet( Address [, Offset] [, Type] )</span> — чтение числа из памяти. <span class="cmd">Address</span> — базовый адрес. <span class="cmd">Offset</span> — смещение от него (в байтах), положительное или отрицательное: его можно применять в циклах для считывания/записи последовательно расположенных чисел; по умолчанию 0. <span class="cmd">Type</span> — тип считываемых данных: те же буквенные обозначения, что и для метода Register, но используются только маленькие буквы; по умолчанию — <b>l</b>. Считанные данные помещаются в возвращаемое методом значение.
<p>
<span class="cmd">NumPut( Var, Address [, Offset] [, Type] )</span> — запись числа в память. <span class="cmd">Var</span> — либо литеральное числовое значение, либо переменная, содержащая значение, которое нужно записать. Остальное — как в NumGet. Возвращаемое методом значение содержит адрес сразу за последним записанным байтом.
<p>
В обоих методах <span class="cmd">Address</span> может быть как числом, так и строкой, в последнем случае в качестве базового адреса используется указатель на эту строку. Это позволяет использовать строки в качестве буфера для данных, размещать там массивы, структуры и т.п.
<p>
<span class="cmd">StrPtr( Var [, Type/Codepage] )</span> — возвращает указатель на строку (на оригинал). <span class="cmd">Var</span> — строковая переменная или константа. <span class="cmd">Type/Codepage</span> — тип/кодировка. Возможные значения: <b>w</b> (по умолчанию), <b>s</b>, <b>z</b>, либо явное указание кодировки — например, "cp1251". При значениях <b>s</b>, <b>z</b> либо кодировке строка предварительно конвертируется на месте. Поддерживается кодировка "cp1201", т.е. UTF-16 Big Endian. Если результирующая строка длиннее исходной, она будет обрезана. Поскольку исходная строка в Юникоде, где каждый символ занимает два байта, места должно быть более чем достаточно в большинстве случаев. Может быть, какой-нибудь восточно-азиатский текст может быть длиннее в ANSI-кодировке или в UTF-8, чем он есть в UTF-16, но это только мои догадки.
<p>
<span class="cmd">StrGet( Address [, Type/Codepage] )</span> — чтение строки с указанного адреса. Возвращает копию строки. <span class="cmd">Address</span> может быть как указателем в виде числа, так и строковой переменной. <span class="cmd">Type/Codepage</span> — то же, что у StrPtr. Значения <b>s</b> и <b>z</b> нужны для чтения строки в ANSI— или OEM—кодировке по умолчанию. Строка при чтении конвертируется в Юникод.
<p>
<span class="cmd">StrPut( String, Address [, Type/Codepage] )</span> — запись строки по указанному адресу. <span class="cmd">Type/Codepage</span> — то же, что у двух методов выше. Строка при записи конвертируется в заданную кодировку. Возвращается адрес после нулевого терминатора строки. Если <span class="cmd">Address</span> указан как 0, метод вернёт размер буфера в памяти, необходимый для записи строки в указанной кодировке, включая нулевой терминатор на конце строки.
<p>
<span class="cmd">Space( Count [, Char] )</span> — создание строки (BSTR) заданной длины. Возвращает строковую переменную. <span class="cmd">Count</span> — число символов (двухбайтных). <span class="cmd">Char</span> — символ, которым будет заполнена строка. По умолчанию строка заполняется пробелами — так же, как это делает функция Space в VBScript. Чтобы заполнить строку двоичными нулями, нужно задать Char как пустую строку ("").
<p>
<u>NB</u>: Изначально этот метод был задуман для создания строк, которые впоследствии будут использованы как буферы памяти — для чисел, структур, выходных строк. Но, как выяснилось на практике, такое использование строк в общем случае ненадёжно. Контроль над памятью, выделенной под строку, отдаётся скриптовому движку, и если он в процессе своей работы произведёт с ней какие-то манипуляции, помещённые вами в неё данные могут быть потеряны или испорчены. Поэтому я рекомендую для выделения памяти под буфер использовать метод MemAlloc (см. ниже).
<p>
<span class="cmd">ObjPtr( Object )</span> — получение указателя на объект.
<p>
<span class="cmd">ObjGet( ObjPtr )</span> — получение объекта по указателю на него. Если объект поддерживает интерфейс IDispatch, возвращается переменная типа VT_DISPATCH; если нет — VT_UNKNOWN. Счётчик ссылок объекта увеличивается на 1.
<p>
<span class="cmd">ArrPtr( Array )</span> — получение указателя на структуру SAFEARRAY массива. Не работает для массивов в JScript, т.к. это объекты.
<p>
<span class="cmd">VarPtr( Variable )</span> — в языках, где переменные передаются в методы по ссылке, как в VBScript, можно получить указатель на структуру VARIANT переменной.
<p>
<span class="cmd">MemAlloc( Bytes [, ZeroMem] )</span> — выделение памяти. Если вторым аргументом указать 1, память будет обнулена. Возвращается указатель на выделенную память.
<p>
<span class="cmd">MemFree( MemPtr )</span> — освобождение ранее выделенной памяти.
<p>
<span class="cmd">Bitness()</span> — определение битности объекта DynamicWrapperX (и, тем самым, битности процесса, его использующего). Возвращает число 32 или 64.
<p>
<span class="cmd">Version( [Field] )</span> — возвращает указанное поле/поля из полного номера версии DynamicWrapperX. Задайте параметру <span class="cmd">Field</span> значение согласно приведённой ниже таблице. Если <span class="cmd">Field</span> опущен, это равносильно 0.
<p>
Пример для версии 2.5.7.10.
<p>
&nbsp;&nbsp;0 — полная версия как строка: "2.5.7.10"<br>
&nbsp;&nbsp;1 — старший номер версии: 2<br>
&nbsp;&nbsp;2 — младший номер версии: 5<br>
&nbsp;&nbsp;3 — номер сборки: 7<br>
&nbsp;&nbsp;4 — номер ревизии: 10 (0xA)<br>
&nbsp;&nbsp;5 — старший + младший номер версии: 0x20005<br>
&nbsp;&nbsp;6 — номер сборки + ревизии: 0x7000A<br>
&nbsp;&nbsp;7 — полный номер версии: 0x200050007000A
<p>
Как вы можете видеть, каждое поле является 16-битным целым и занимает 2 байта.
<p>
<a href="#contents">Наверх</a>

    <h3 id="addons">Примеры использования методов</h3>
<p>
<b>JScript</b>
<pre>
DWX = new ActiveXObject("DynamicWrapperX");
str = "Hello, world! Это я.";

<span>// Чтение из памяти. Читаются коды символов строки.</span>

codes = "";

for(i=0; i < str.length; ++i)
  codes += DWX.NumGet(str, i*2, "t") + " ";   <span>// i умножается на 2, т.к. смещение должно</span>
                                              <span>// быть в байтах, а тип "t" - двухбайтный.</span>
WScript.Echo("Коды символов:\n" + codes);

<span>// Чтение и запись. Строка записывается в обратном порядке символов.</span>

len = str.length;
buf = DWX.MemAlloc(len * 2 + 2);        <span>// Буфер для записи. Каждый символ Юникода = 2 байта.</span>
DWX.NumPut(0, buf, len * 2, "t");       <span>// Записать 2 нулевых байта в конец (терминатор строки).</span>

for(i=0, j=len-1; i < len; ++i, --j) {  <span>// По смещению len-1 символов находится последний символ.</span>
  code = DWX.NumGet(str, i*2, "t");     <span>// Читаем слева направо (смещение растёт).</span>
  DWX.NumPut(code, buf, j*2, "t");      <span>// Пишем справа налево (смещение уменьшается).</span>
}

str1 = DWX.StrGet(buf);
DWX.MemFree(buf);
WScript.Echo("Строка наоборот:\n" + str1);

<span>// Операции со строками.</span>

ptr = DWX.StrPtr(str);                  <span>// Получение указателя на строку в виде числа,</span>
                                        <span>// строка остаётся в Юникоде.</span>
WScript.Echo("Адрес строки: " + ptr);

ptr = DWX.StrPtr(str, "z");             <span>// Получение указателя на ту же строку,</span>
                                        <span>// предварительно конвертированную в OEM/DOS.</span>
str1 = DWX.StrGet(ptr, "z");            <span>// Чтение этой строки по указателю,</span>
                                        <span>// с обратной конвертацией.</span>
WScript.Echo("Восстановленная строка:\n" + str1);

<span>// Создать копию строки в UTF-8.</span>

bufsize = DWX.StrPut(str1, 0, "cp65001");
buf = DWX.MemAlloc(bufsize);
DWX.StrPut(str1, buf, "cp65001");

<span>// Прочитать обратно в Юникод.</span>

str2 = DWX.StrGet(buf, "cp65001");
DWX.MemFree(buf);
WScript.Echo("Прочитано из UTF-8:\n" + str2);

</pre>
<p>
<a href="#contents">Наверх</a>
<p>
&nbsp;
<p>
<b>VBScript</b>
<pre>
Set DWX = CreateObject("DynamicWrapperX")
str = "Hello, world! Это я."

<span>' Чтение из памяти. Читаются коды символов строки.</span>

strlen = Len(str)
codes = ""

For i=0 To strlen-1
  codes = codes & DWX.NumGet(str, i*2, "t") & " "  <span>' i умножается на 2, т.к. смещение должно</span>
Next                                               <span>' быть в байтах, а тип "t" - двухбайтный.</span>

WScript.Echo "Коды символов:" & vbCrLf & codes

<span>' Чтение и запись. Строка записывается в обратном порядке символов.</span>

buf = DWX.MemAlloc(strlen * 2 + 2)  <span>' Буфер для записи. Каждый символ Юникода = 2 байта.</span>
DWX.NumPut 0, buf, strlen * 2, "t"  <span>' Записать 2 нулевых байта в конец (терминатор строки).</span>
j = strlen-1                        <span>' По смещению strlen-1 символов находится последний символ.</span>

For i=0 To strlen-1
  code = DWX.NumGet(str, i*2, "t")   <span>' Читаем слева направо (смещение растёт).</span>
  DWX.NumPut code, buf, j*2, "t"     <span>' Пишем справа налево (смещение уменьшается).</span>
  j = j-1
Next

str1 = DWX.StrGet(buf)
DWX.MemFree buf
WScript.Echo "Строка наоборот:" & vbCrLf & str1

<span>' Операции со строками.</span>

ptr = DWX.StrPtr(str)                 <span>' Получение указателя на строку в виде числа,</span>
                                      <span>' строка остаётся в Юникоде.</span>
WScript.Echo "Адрес строки: " & ptr

ptr = DWX.StrPtr(str, "z")            <span>' Получение указателя на ту же строку,</span>
                                      <span>' предварительно конвертированную в OEM/DOS.</span>
str1 = DWX.StrGet(ptr, "z")           <span>' Чтение этой строки по указателю, с обратной конвертацией.</span>

WScript.Echo "Восстановленная строка:" & vbCrLf & str1

<span>' Создать копию строки в UTF-8.</span>

bufsize = DWX.StrPut(str1, 0, "cp65001")
buf = DWX.MemAlloc(bufsize)
DWX.StrPut str1, buf, "cp65001"

<span>' Прочитать обратно в Юникод.</span>

str2 = DWX.StrGet(buf, "cp65001")
DWX.MemFree buf
WScript.Echo "Прочитано из UTF-8:" & vbCrLf & str2
</pre>
<p>
<a href="#contents">Наверх</a>
</div>
</body>
</html>